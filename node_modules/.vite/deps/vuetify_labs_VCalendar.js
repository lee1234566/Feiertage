import {
  VChip
} from "./chunk-E2YO7HRH.js";
import "./chunk-6JQ7JQSP.js";
import {
  VSheet
} from "./chunk-KN7XUSMQ.js";
import "./chunk-GEXLWBPO.js";
import "./chunk-2PSEIA2V.js";
import {
  VBtn
} from "./chunk-OYYTK3HW.js";
import "./chunk-VA5UY7AC.js";
import {
  getWeek,
  useDate
} from "./chunk-JRMYPV4V.js";
import "./chunk-C3BQ33FV.js";
import "./chunk-2LVZ4BCA.js";
import "./chunk-HVY6G2XK.js";
import "./chunk-3VFYVJPC.js";
import {
  makeLocationProps,
  useLocation
} from "./chunk-W36DYVEZ.js";
import "./chunk-MSXP5XQI.js";
import "./chunk-L5NXHKFQ.js";
import {
  VIcon
} from "./chunk-BM4NPVC4.js";
import "./chunk-P2OQWTEP.js";
import "./chunk-V33E6EAP.js";
import {
  IconValue
} from "./chunk-CNAYGJQP.js";
import "./chunk-ZEBOZD2A.js";
import {
  makeTagProps
} from "./chunk-QQKFUYIT.js";
import {
  useLocale
} from "./chunk-65XVJOQC.js";
import {
  useProxiedModel
} from "./chunk-N6ISWRIS.js";
import {
  makeThemeProps,
  useTheme
} from "./chunk-F42WMXEK.js";
import "./chunk-UPJP2KXQ.js";
import {
  MaybeTransition,
  makeTransitionProps
} from "./chunk-UP4CE2IR.js";
import "./chunk-53NFPIGH.js";
import {
  makeRoundedProps,
  useRounded
} from "./chunk-E6EDU2KJ.js";
import {
  useBackgroundColor,
  useTextColor
} from "./chunk-5LS3R7VF.js";
import {
  chunkArray,
  convertToUnit,
  genericComponent,
  makeComponentProps,
  pickWithRest,
  propsFactory,
  useRender,
  wrapInArray
} from "./chunk-MT3A2Y4Q.js";
import {
  computed,
  createVNode,
  mergeProps,
  toRef,
  vShow,
  withDirectives
} from "./chunk-ESTIRR4N.js";
import "./chunk-CSAU5B4Q.js";

// node_modules/vuetify/lib/labs/VCalendar/VCalendar.mjs
import "/Users/anneliepflue/Feiertage/node_modules/vuetify/lib/labs/VCalendar/VCalendar.css";

// node_modules/vuetify/lib/labs/VCalendar/VCalendarDay.mjs
import "/Users/anneliepflue/Feiertage/node_modules/vuetify/lib/labs/VCalendar/VCalendarDay.css";

// node_modules/vuetify/lib/labs/VCalendar/VCalendarInterval.mjs
import "/Users/anneliepflue/Feiertage/node_modules/vuetify/lib/labs/VCalendar/VCalendarInterval.css";

// node_modules/vuetify/lib/labs/VCalendar/VCalendarIntervalEvent.mjs
var makeVCalendarIntervalEventProps = propsFactory({
  allDay: Boolean,
  interval: Object,
  intervalDivisions: {
    type: Number,
    required: true
  },
  intervalDuration: {
    type: Number,
    required: true
  },
  intervalHeight: {
    type: Number,
    required: true
  },
  event: Object
}, "VCalendarIntervalEvent");
var VCalendarIntervalEvent = genericComponent()({
  name: "VCalendarIntervalEvent",
  props: makeVCalendarIntervalEventProps(),
  setup(props) {
    const adapter = useDate();
    const calcHeight = () => {
      var _a, _b, _c, _d;
      if (!((_a = props.event) == null ? void 0 : _a.first) && !((_b = props.event) == null ? void 0 : _b.last) || adapter.isEqual((_c = props.event) == null ? void 0 : _c.start, (_d = props.interval) == null ? void 0 : _d.start)) {
        return {
          height: "100%",
          margin: convertToUnit(0)
        };
      } else {
        const {
          height,
          margin
        } = Array.from({
          length: props.intervalDivisions
        }, (x) => x * (props.intervalDuration / props.intervalDivisions)).reduce((total, div, index) => {
          var _a2, _b2;
          if (adapter.isBefore(adapter.addMinutes((_a2 = props.interval) == null ? void 0 : _a2.start, div), (_b2 = props.event) == null ? void 0 : _b2.start)) {
            return {
              height: convertToUnit(props.intervalHeight / props.intervalDivisions * index),
              margin: convertToUnit(props.intervalHeight / props.intervalDivisions * index)
            };
          }
          return {
            height: total.height,
            margin: total.margin
          };
        }, {
          height: "",
          margin: ""
        });
        return {
          height,
          margin
        };
      }
    };
    useRender(() => {
      var _a, _b, _c, _d, _e;
      return createVNode(VSheet, {
        "height": calcHeight().height,
        "density": "comfortable",
        "style": `width: 100%; margin-top: ${calcHeight().margin}`,
        "class": "align-center pa-1",
        "color": ((_a = props.event) == null ? void 0 : _a.color) ?? void 0,
        "rounded": ((_b = props.event) == null ? void 0 : _b.first) && ((_c = props.event) == null ? void 0 : _c.last) ? true : ((_d = props.event) == null ? void 0 : _d.first) ? "t" : ((_e = props.event) == null ? void 0 : _e.last) ? "b" : false
      }, {
        default: () => {
          var _a2, _b2;
          return [((_a2 = props.event) == null ? void 0 : _a2.first) ? (_b2 = props.event) == null ? void 0 : _b2.title : ""];
        }
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VCalendar/VCalendarInterval.mjs
var makeVCalendarIntervalProps = propsFactory({
  day: {
    type: Object,
    default: () => ({})
  },
  dayIndex: Number,
  events: Array,
  intervalDivisions: {
    type: Number,
    default: 2
  },
  intervalDuration: {
    type: Number,
    default: 60
  },
  intervalHeight: {
    type: Number,
    default: 48
  },
  intervalFormat: {
    type: [String, Function],
    default: "fullTime12h"
  },
  intervalStart: {
    type: Number,
    default: 0
  }
}, "VCalendarInterval");
var VCalendarInterval = genericComponent()({
  name: "VCalendarInterval",
  props: {
    index: {
      type: Number,
      required: true
    },
    ...makeVCalendarIntervalProps()
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const adapter = useDate();
    const interval = computed(() => {
      const start = adapter.addMinutes(adapter.startOfDay(props.day.date), props.intervalDuration * (props.index + props.intervalStart));
      const end = adapter.addMinutes(adapter.startOfDay(props.day.date), props.intervalDuration * (props.index + props.intervalStart + 1) - 1);
      return {
        ...props.day,
        label: adapter.format(start, "fullTime24h"),
        start,
        end,
        events: props.events ? props.events.filter((e) => !e.allDay && (adapter.isEqual(start, e.start) || adapter.isWithinRange(e.start, [start, end]) || adapter.isWithinRange(start, [e.start, e.end]) || adapter.isEqual(end, e.end))).map((e) => {
          return {
            ...e,
            first: adapter.isEqual(start, e.start) || adapter.isWithinRange(e.start, [start, end]),
            last: adapter.isEqual(end, e.end) || adapter.isWithinRange(e.end, [start, end])
          };
        }) : []
      };
    });
    useRender(() => {
      var _a, _b;
      return props.dayIndex === 0 ? createVNode("div", {
        "class": "v-calendar-day__row-with-label",
        "style": `height: ${convertToUnit(props.intervalHeight)}`
      }, [createVNode("div", {
        "class": "v-calendar-day__row-label"
      }, [createVNode("slot", {
        "name": "intervalFormat",
        "interval": interval.value
      }, [props.index ? props.intervalFormat ? typeof props.intervalFormat === "string" ? adapter.format(interval.value.start, "hours12h") : props.intervalFormat(interval.value) : interval.value.label : ""])]), createVNode("div", {
        "class": "v-calendar-day__row-hairline"
      }, null), createVNode("div", {
        "class": ["v-calendar-day__row-content", interval.value.events.some((e) => !e.last) ? "v-calendar-day__row-content-through" : ""]
      }, [createVNode("slot", {
        "name": "intervalBody",
        "interval": interval.value
      }, [(_a = interval.value.events) == null ? void 0 : _a.map((event) => createVNode(VCalendarIntervalEvent, {
        "event": event,
        "interval": interval.value,
        "intervalDivisions": props.intervalDivisions,
        "intervalDuration": props.intervalDuration,
        "intervalHeight": props.intervalHeight
      }, null))])])]) : createVNode("div", {
        "class": "v-calendar-day__row-without-label",
        "style": `height: ${convertToUnit(props.intervalHeight)}`
      }, [createVNode("div", {
        "class": ["v-calendar-day__row-content", interval.value.events.some((e) => !e.last) ? "v-calendar-day__row-content-through" : ""]
      }, [createVNode("slot", {
        "name": "intervalBody",
        "interval": interval.value
      }, [(_b = interval.value.events) == null ? void 0 : _b.filter((event) => !event.allDay).map((event) => createVNode(VCalendarIntervalEvent, {
        "event": event,
        "interval": interval.value,
        "intervalDivisions": props.intervalDivisions,
        "intervalDuration": props.intervalDuration,
        "intervalHeight": props.intervalHeight
      }, null))])])]);
    });
    return {
      interval
    };
  }
});

// node_modules/vuetify/lib/labs/VCalendar/VCalendarDay.mjs
var makeVCalendarDayProps = propsFactory({
  hideDayHeader: Boolean,
  intervals: {
    type: Number,
    default: 24
  },
  ...makeVCalendarIntervalProps()
}, "VCalendarDay");
var VCalendarDay = genericComponent()({
  name: "VCalendarDay",
  props: makeVCalendarDayProps(),
  setup(props) {
    const adapter = useDate();
    const intervals = computed(() => [...Array.from({
      length: props.intervals
    }, (v, i) => i).filter((int, index) => props.intervalDuration * (index + props.intervalStart) < 1440)]);
    useRender(() => {
      const calendarIntervalProps = VCalendarInterval.filterProps(props);
      return createVNode("div", {
        "class": "v-calendar-day__container"
      }, [!props.hideDayHeader && createVNode("div", {
        "key": "calender-week-name",
        "class": "v-calendar-weekly__head-weekday"
      }, [adapter.format(props.day.date, "weekdayShort"), createVNode("div", null, [createVNode(VBtn, {
        "icon": true,
        "text": adapter.format(props.day.date, "dayOfMonth"),
        "variant": "text"
      }, null)])]), intervals.value.map((_, index) => createVNode(VCalendarInterval, mergeProps({
        "index": index
      }, calendarIntervalProps), null))]);
    });
    return {
      intervals
    };
  }
});

// node_modules/vuetify/lib/labs/VCalendar/VCalendarHeader.mjs
import "/Users/anneliepflue/Feiertage/node_modules/vuetify/lib/labs/VCalendar/VCalendarHeader.css";
var makeVCalendarHeaderProps = propsFactory({
  nextIcon: {
    type: String,
    default: "$next"
  },
  prevIcon: {
    type: String,
    default: "$prev"
  },
  title: String,
  text: {
    type: String,
    default: "$vuetify.calendar.today"
  },
  viewMode: {
    type: String,
    default: "month"
  }
}, "VCalendarHeader");
var VCalendarHeader = genericComponent()({
  name: "VCalendarHeader",
  props: makeVCalendarHeaderProps(),
  emits: {
    "click:next": () => true,
    "click:prev": () => true,
    "click:toToday": () => true
  },
  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const {
      t
    } = useLocale();
    function prev() {
      emit("click:prev");
    }
    function next() {
      emit("click:next");
    }
    function toToday() {
      emit("click:toToday");
    }
    useRender(() => createVNode("div", {
      "class": "v-calendar-header"
    }, [props.text && createVNode(VBtn, {
      "key": "today",
      "class": "v-calendar-header__today",
      "text": t(props.text),
      "variant": "outlined",
      "onClick": toToday
    }, null), createVNode(VBtn, {
      "density": "comfortable",
      "icon": props.prevIcon,
      "variant": "text",
      "onClick": prev
    }, null), createVNode(VBtn, {
      "density": "comfortable",
      "icon": props.nextIcon,
      "variant": "text",
      "onClick": next
    }, null), createVNode("div", {
      "class": "v-calendar-header__title"
    }, [props.title])]));
    return {};
  }
});

// node_modules/vuetify/lib/labs/VCalendar/VCalendarMonthDay.mjs
import "/Users/anneliepflue/Feiertage/node_modules/vuetify/lib/labs/VCalendar/VCalendarMonthDay.css";

// node_modules/vuetify/lib/components/VBadge/VBadge.mjs
import "/Users/anneliepflue/Feiertage/node_modules/vuetify/lib/components/VBadge/VBadge.css";
var makeVBadgeProps = propsFactory({
  bordered: Boolean,
  color: String,
  content: [Number, String],
  dot: Boolean,
  floating: Boolean,
  icon: IconValue,
  inline: Boolean,
  label: {
    type: String,
    default: "$vuetify.badge"
  },
  max: [Number, String],
  modelValue: {
    type: Boolean,
    default: true
  },
  offsetX: [Number, String],
  offsetY: [Number, String],
  textColor: String,
  ...makeComponentProps(),
  ...makeLocationProps({
    location: "top end"
  }),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeTransitionProps({
    transition: "scale-rotate-transition"
  })
}, "VBadge");
var VBadge = genericComponent()({
  name: "VBadge",
  inheritAttrs: false,
  props: makeVBadgeProps(),
  setup(props, ctx) {
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    const {
      roundedClasses
    } = useRounded(props);
    const {
      t
    } = useLocale();
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "textColor"));
    const {
      themeClasses
    } = useTheme();
    const {
      locationStyles
    } = useLocation(props, true, (side) => {
      const base = props.floating ? props.dot ? 2 : 4 : props.dot ? 8 : 12;
      return base + (["top", "bottom"].includes(side) ? +(props.offsetY ?? 0) : ["left", "right"].includes(side) ? +(props.offsetX ?? 0) : 0);
    });
    useRender(() => {
      const value = Number(props.content);
      const content = !props.max || isNaN(value) ? props.content : value <= +props.max ? value : `${props.max}+`;
      const [badgeAttrs, attrs] = pickWithRest(ctx.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
      return createVNode(props.tag, mergeProps({
        "class": ["v-badge", {
          "v-badge--bordered": props.bordered,
          "v-badge--dot": props.dot,
          "v-badge--floating": props.floating,
          "v-badge--inline": props.inline
        }, props.class]
      }, attrs, {
        "style": props.style
      }), {
        default: () => {
          var _a, _b;
          return [createVNode("div", {
            "class": "v-badge__wrapper"
          }, [(_b = (_a = ctx.slots).default) == null ? void 0 : _b.call(_a), createVNode(MaybeTransition, {
            "transition": props.transition
          }, {
            default: () => {
              var _a2, _b2;
              return [withDirectives(createVNode("span", mergeProps({
                "class": ["v-badge__badge", themeClasses.value, backgroundColorClasses.value, roundedClasses.value, textColorClasses.value],
                "style": [backgroundColorStyles.value, textColorStyles.value, props.inline ? {} : locationStyles.value],
                "aria-atomic": "true",
                "aria-label": t(props.label, value),
                "aria-live": "polite",
                "role": "status"
              }, badgeAttrs), [props.dot ? void 0 : ctx.slots.badge ? (_b2 = (_a2 = ctx.slots).badge) == null ? void 0 : _b2.call(_a2) : props.icon ? createVNode(VIcon, {
                "icon": props.icon
              }, null) : content]), [[vShow, props.modelValue]])];
            }
          })])];
        }
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VCalendar/VCalendarEvent.mjs
var makeVCalendarEventProps = propsFactory({
  allDay: Boolean,
  day: Object,
  event: Object
}, "VCalendarEvent");
var VCalendarEvent = genericComponent()({
  name: "VCalendarEvent",
  props: makeVCalendarEventProps(),
  setup(props) {
    useRender(() => createVNode(VChip, {
      "color": props.allDay ? "primary" : void 0,
      "density": "comfortable",
      "label": props.allDay,
      "width": "100%"
    }, {
      default: () => {
        var _a, _b;
        return [createVNode(VBadge, {
          "inline": true,
          "dot": true,
          "color": (_a = props.event) == null ? void 0 : _a.color
        }, null), (_b = props.event) == null ? void 0 : _b.title];
      }
    }));
    return {};
  }
});

// node_modules/vuetify/lib/labs/VCalendar/VCalendarMonthDay.mjs
var makeVCalendarMonthDayProps = propsFactory({
  active: Boolean,
  color: String,
  day: Object,
  disabled: Boolean,
  events: Array,
  title: [Number, String]
}, "VCalendarMonthDay");
var VCalendarMonthDay = genericComponent()({
  name: "VCalendarMonthDay",
  props: makeVCalendarMonthDayProps(),
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    useRender(() => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      const hasTitle = !!(props.title || ((_a = slots.title) == null ? void 0 : _a.call(slots, {
        title: props.title
      })));
      return createVNode("div", {
        "class": ["v-calendar-month__day"]
      }, [!((_b = props.day) == null ? void 0 : _b.isHidden) && hasTitle && createVNode("div", {
        "key": "title",
        "class": "v-calendar-weekly__day-label"
      }, [((_c = slots.title) == null ? void 0 : _c.call(slots, {
        title: props.title
      })) ?? createVNode(VBtn, {
        "class": ((_d = props.day) == null ? void 0 : _d.isToday) ? "v-calendar-weekly__day-label__today" : void 0,
        "color": props.color,
        "disabled": props.disabled,
        "icon": true,
        "size": "x-small",
        "variant": ((_e = props.day) == null ? void 0 : _e.isToday) ? void 0 : "flat"
      }, {
        default: () => [props.title]
      })]), createVNode("div", {
        "key": "content",
        "class": "v-calendar-weekly__day-content"
      }, [((_f = slots.content) == null ? void 0 : _f.call(slots)) ?? createVNode("div", null, [createVNode("div", {
        "class": "v-calendar-weekly__day-alldayevents-container"
      }, [(_g = props.events) == null ? void 0 : _g.filter((event) => event.allDay).map((event) => createVNode(VCalendarEvent, {
        "day": props.day,
        "event": event,
        "allDay": true
      }, null))]), createVNode("div", {
        "class": "v-calendar-weekly__day-events-container"
      }, [(_h = props.events) == null ? void 0 : _h.filter((event) => !event.allDay).map((event) => createVNode(VCalendarEvent, {
        "day": props.day,
        "event": event
      }, null))])])]), (_i = slots.default) == null ? void 0 : _i.call(slots)]);
    });
    return {};
  }
});

// node_modules/vuetify/lib/composables/calendar.mjs
var makeCalendarProps = propsFactory({
  allowedDates: [Array, Function],
  disabled: Boolean,
  displayValue: null,
  modelValue: Array,
  month: [Number, String],
  max: null,
  min: null,
  showAdjacentMonths: Boolean,
  year: [Number, String],
  weekdays: {
    type: Array,
    default: () => [0, 1, 2, 3, 4, 5, 6]
  }
}, "calendar");
function useCalendar(props) {
  const adapter = useDate();
  const model = useProxiedModel(props, "modelValue", [], (v) => wrapInArray(v));
  const displayValue = computed(() => {
    if (props.displayValue)
      return adapter.date(props.displayValue);
    if (model.value.length > 0)
      return adapter.date(model.value[0]);
    if (props.min)
      return adapter.date(props.min);
    if (Array.isArray(props.allowedDates))
      return adapter.date(props.allowedDates[0]);
    return adapter.date();
  });
  const year = useProxiedModel(props, "year", void 0, (v) => {
    const value = v != null ? Number(v) : adapter.getYear(displayValue.value);
    return adapter.startOfYear(adapter.setYear(adapter.date(), value));
  }, (v) => adapter.getYear(v));
  const month = useProxiedModel(props, "month", void 0, (v) => {
    const value = v != null ? Number(v) : adapter.getMonth(displayValue.value);
    const date = adapter.setYear(adapter.date(), adapter.getYear(year.value));
    return adapter.setMonth(date, value);
  }, (v) => adapter.getMonth(v));
  const weeksInMonth = computed(() => {
    const weeks = adapter.getWeekArray(month.value);
    const days = weeks.flat();
    const daysInMonth2 = 6 * 7;
    if (days.length < daysInMonth2) {
      const lastDay = days[days.length - 1];
      let week = [];
      for (let day = 1; day <= daysInMonth2 - days.length; day++) {
        week.push(adapter.addDays(lastDay, day));
        if (day % 7 === 0) {
          weeks.push(week);
          week = [];
        }
      }
    }
    return weeks;
  });
  function genDays(days, today) {
    return days.filter((date) => {
      return props.weekdays.includes(adapter.toJsDate(date).getDay());
    }).map((date, index) => {
      const isoDate = adapter.toISO(date);
      const isAdjacent = !adapter.isSameMonth(date, month.value);
      const isStart = adapter.isSameDay(date, adapter.startOfMonth(month.value));
      const isEnd = adapter.isSameDay(date, adapter.endOfMonth(month.value));
      const isSame = adapter.isSameDay(date, month.value);
      return {
        date,
        isoDate,
        formatted: adapter.format(date, "keyboardDate"),
        year: adapter.getYear(date),
        month: adapter.getMonth(date),
        isDisabled: isDisabled(date),
        isWeekStart: index % 7 === 0,
        isWeekEnd: index % 7 === 6,
        isToday: adapter.isSameDay(date, today),
        isAdjacent,
        isHidden: isAdjacent && !props.showAdjacentMonths,
        isStart,
        isSelected: model.value.some((value) => adapter.isSameDay(date, value)),
        isEnd,
        isSame,
        localized: adapter.format(date, "dayOfMonth")
      };
    });
  }
  const daysInWeek = computed(() => {
    const lastDay = adapter.startOfWeek(model.value);
    const week = [];
    for (let day = 0; day <= 6; day++) {
      week.push(adapter.addDays(lastDay, day));
    }
    const days = week;
    const today = adapter.date();
    return genDays(days, today);
  });
  const daysInMonth = computed(() => {
    const days = weeksInMonth.value.flat();
    const today = adapter.date();
    return genDays(days, today);
  });
  const weekNumbers = computed(() => {
    return weeksInMonth.value.map((week) => {
      return week.length ? getWeek(adapter, week[0]) : null;
    });
  });
  function isDisabled(value) {
    if (props.disabled)
      return true;
    const date = adapter.date(value);
    if (props.min && adapter.isAfter(adapter.date(props.min), date))
      return true;
    if (props.max && adapter.isAfter(date, adapter.date(props.max)))
      return true;
    if (Array.isArray(props.allowedDates) && props.allowedDates.length > 0) {
      return !props.allowedDates.some((d) => adapter.isSameDay(adapter.date(d), date));
    }
    if (typeof props.allowedDates === "function") {
      return !props.allowedDates(date);
    }
    return false;
  }
  return {
    displayValue,
    daysInMonth,
    daysInWeek,
    genDays,
    model,
    weeksInMonth,
    weekNumbers
  };
}

// node_modules/vuetify/lib/labs/VCalendar/VCalendar.mjs
var makeVCalendarProps = propsFactory({
  hideHeader: Boolean,
  hideWeekNumber: Boolean,
  ...makeCalendarProps(),
  ...makeVCalendarDayProps(),
  ...makeVCalendarHeaderProps()
}, "VCalender");
var VCalendar = genericComponent()({
  name: "VCalendar",
  props: makeVCalendarProps(),
  emits: {
    next: null,
    prev: null,
    "update:modelValue": null
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const adapter = useDate();
    const {
      daysInMonth,
      daysInWeek,
      genDays,
      model,
      weekNumbers
    } = useCalendar(props);
    const dayNames = adapter.getWeekdays();
    function onClickNext() {
      if (props.viewMode === "month") {
        model.value = [adapter.addMonths(model.value[0], 1)];
      }
      if (props.viewMode === "week") {
        model.value = [adapter.addDays(model.value[0], 7)];
      }
      if (props.viewMode === "day") {
        model.value = [adapter.addDays(model.value[0], 1)];
      }
    }
    function onClickPrev() {
      if (props.viewMode === "month") {
        model.value = [adapter.addMonths(model.value[0], -1)];
      }
      if (props.viewMode === "week") {
        model.value = [adapter.addDays(model.value[0], -7)];
      }
      if (props.viewMode === "day") {
        model.value = [adapter.addDays(model.value[0], -1)];
      }
    }
    function onClickToday() {
      model.value = [/* @__PURE__ */ new Date()];
    }
    const title = computed(() => {
      return adapter.format(model.value[0], "monthAndYear");
    });
    useRender(() => {
      var _a;
      const calendarDayProps = VCalendarDay.filterProps(props);
      const calendarHeaderProps = VCalendarHeader.filterProps(props);
      return createVNode("div", {
        "class": ["v-calendar", {
          "v-calendar-monthly": props.viewMode === "month",
          "v-calendar-weekly": props.viewMode === "week",
          "v-calendar-day": props.viewMode === "day"
        }]
      }, [createVNode("div", null, [!props.hideHeader && (!slots.header ? createVNode(VCalendarHeader, mergeProps({
        "key": "calendar-header"
      }, calendarHeaderProps, {
        "title": title.value,
        "onClick:next": onClickNext,
        "onClick:prev": onClickPrev,
        "onClick:toToday": onClickToday
      }), null) : slots.header({
        title: title.value
      }))]), createVNode("div", {
        "class": ["v-calendar__container", `days__${props.weekdays.length}`]
      }, [props.viewMode === "month" && !props.hideDayHeader && createVNode("div", {
        "class": ["v-calendar-weekly__head", `days__${props.weekdays.length}`, ...!props.hideWeekNumber ? ["v-calendar-weekly__head-weeknumbers"] : []],
        "key": "calenderWeeklyHead"
      }, [!props.hideWeekNumber ? createVNode("div", {
        "key": "weekNumber0",
        "class": "v-calendar-weekly__head-weeknumber"
      }, null) : "", props.weekdays.sort((a, b) => a - b).map((weekday) => createVNode("div", {
        "class": `v-calendar-weekly__head-weekday${!props.hideWeekNumber ? "-with-weeknumber" : ""}`
      }, [dayNames[weekday]]))]), props.viewMode === "month" && createVNode("div", {
        "key": "VCalendarMonth",
        "class": ["v-calendar-month__days", `days${!props.hideWeekNumber ? "-with-weeknumbers" : ""}__${props.weekdays.length}`, ...!props.hideWeekNumber ? ["v-calendar-month__weeknumbers"] : []]
      }, [chunkArray(daysInMonth.value, props.weekdays.length).map((week, wi) => [!props.hideWeekNumber ? createVNode("div", {
        "class": "v-calendar-month__weeknumber"
      }, [weekNumbers.value[wi]]) : "", week.map((day) => {
        var _a2;
        return createVNode(VCalendarMonthDay, {
          "color": adapter.isSameDay(/* @__PURE__ */ new Date(), day.date) ? "primary" : void 0,
          "day": day,
          "title": day ? adapter.format(day.date, "dayOfMonth") : "NaN",
          "events": (_a2 = props.events) == null ? void 0 : _a2.filter((e) => adapter.isSameDay(day.date, e.start) || adapter.isSameDay(day.date, e.end))
        }, null);
      })])]), props.viewMode === "week" && daysInWeek.value.map((day, i) => {
        var _a2;
        return createVNode(VCalendarDay, mergeProps(calendarDayProps, {
          "day": day,
          "dayIndex": i,
          "events": (_a2 = props.events) == null ? void 0 : _a2.filter((e) => adapter.isSameDay(e.start, day.date) || adapter.isSameDay(e.end, day.date))
        }), null);
      }), props.viewMode === "day" && createVNode(VCalendarDay, mergeProps(calendarDayProps, {
        "day": genDays([model.value[0]], adapter.date())[0],
        "events": (_a = props.events) == null ? void 0 : _a.filter((e) => adapter.isSameDay(e.start, genDays([model.value[0]], adapter.date())[0].date) || adapter.isSameDay(e.end, genDays([model.value[0]], adapter.date())[0].date))
      }), null)])]);
    });
    return {
      daysInMonth,
      daysInWeek,
      genDays
    };
  }
});
export {
  VCalendar,
  VCalendarDay,
  VCalendarHeader,
  VCalendarInterval,
  VCalendarIntervalEvent,
  VCalendarMonthDay
};
//# sourceMappingURL=vuetify_labs_VCalendar.js.map
